name: Build and Publish MCP Servers (Improved)

on:
  push:
    branches: [main, develop]
    tags: ['v*']
    paths:
      - 'databricks-mcp/**'
      - 'snowflake-mcp/**'
      - 'sqlserver-mcp/**'
      - '.github/workflows/build-and-publish*.yml'
  pull_request:
    branches: [main, develop]
    paths:
      - 'databricks-mcp/**'
      - 'snowflake-mcp/**'
      - 'sqlserver-mcp/**'
      - '.github/workflows/build-and-publish*.yml'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to build and publish'
        required: false
        default: 'latest'
      publish:
        description: 'Publish to registries'
        required: false
        default: 'false'
        type: choice
        options: ['true', 'false']
      skip_tests:
        description: 'Skip container tests'
        required: false
        default: 'false'
        type: choice
        options: ['true', 'false']
      servers:
        description: 'Servers to build (comma-separated or "all")'
        required: false
        default: 'all'

env:
  REGISTRY_GHCR: ghcr.io
  REGISTRY_DOCKER: docker.io

permissions:
  contents: read
  packages: write
  security-events: write
  actions: read

jobs:
  # Step 1: Detect what needs to be built
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      snowflake: ${{ steps.changes.outputs.snowflake }}
      databricks: ${{ steps.changes.outputs.databricks }}
      sqlserver: ${{ steps.changes.outputs.sqlserver }}
      any-server: ${{ steps.determine.outputs.any-server }}
      servers-matrix: ${{ steps.determine.outputs.servers-matrix }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect file changes
        uses: dorny/paths-filter@v2
        id: changes
        with:
          base: ${{ github.event.before || 'HEAD~1' }}
          filters: |
            snowflake:
              - 'snowflake-mcp/**'
            databricks:
              - 'databricks-mcp/**'
            sqlserver:
              - 'sqlserver-mcp/**'

      - name: Determine build matrix
        id: determine
        run: |
          # Handle manual server selection
          if [[ "${{ github.event.inputs.servers }}" != "" && "${{ github.event.inputs.servers }}" != "all" ]]; then
            SERVERS="${{ github.event.inputs.servers }}"
            # Convert comma-separated list to JSON array
            MATRIX=$(echo "$SERVERS" | tr ',' '\n' | jq -R . | jq -s .)
            echo "servers-matrix=$MATRIX" >> $GITHUB_OUTPUT
            echo "any-server=true" >> $GITHUB_OUTPUT
          else
            # Auto-detect based on changes
            SERVERS=()
            if [[ "${{ steps.changes.outputs.snowflake }}" == "true" ]]; then
              SERVERS+=("snowflake-mcp")
            fi
            if [[ "${{ steps.changes.outputs.databricks }}" == "true" ]]; then
              SERVERS+=("databricks-mcp")
            fi
            if [[ "${{ steps.changes.outputs.sqlserver }}" == "true" ]]; then
              SERVERS+=("sqlserver-mcp")
            fi
            
            # If workflow_dispatch or no changes detected, build all
            if [[ ${#SERVERS[@]} -eq 0 || "${{ github.event_name }}" == "workflow_dispatch" ]]; then
              SERVERS=("snowflake-mcp" "databricks-mcp" "sqlserver-mcp")
            fi
            
            # Convert to JSON array
            if [[ ${#SERVERS[@]} -gt 0 ]]; then
              MATRIX=$(printf '%s\n' "${SERVERS[@]}" | jq -R . | jq -s .)
              echo "servers-matrix=$MATRIX" >> $GITHUB_OUTPUT
              echo "any-server=true" >> $GITHUB_OUTPUT
            else
              echo "servers-matrix=[]" >> $GITHUB_OUTPUT
              echo "any-server=false" >> $GITHUB_OUTPUT
            fi
          fi

  # Step 2: Security scan (can run independently)
  security-scan:
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.any-server == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # Step 3: Build Docker images (per server, recoverable)
  build-images:
    runs-on: ubuntu-latest
    needs: [detect-changes]
    if: needs.detect-changes.outputs.any-server == 'true'
    strategy:
      matrix:
        server: ${{ fromJson(needs.detect-changes.outputs.servers-matrix) }}
      fail-fast: false
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY_GHCR }}/${{ github.repository_owner }}/${{ matrix.server }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ github.event.inputs.version }},enable=${{ github.event_name == 'workflow_dispatch' }}

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./${{ matrix.server }}
          platforms: linux/amd64,linux/arm64
          push: false
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=oci,dest=/tmp/${{ matrix.server }}.tar

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.server }}-image-${{ github.run_id }}-${{ github.run_attempt }}
          path: /tmp/${{ matrix.server }}.tar
          retention-days: 1

  # Step 4: Test containers (per server, can be skipped)
  test-containers:
    runs-on: ubuntu-latest
    needs: [detect-changes, build-images]
    if: needs.detect-changes.outputs.any-server == 'true' && github.event.inputs.skip_tests != 'true'
    strategy:
      matrix:
        server: ${{ fromJson(needs.detect-changes.outputs.servers-matrix) }}
      fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.server }}-image-${{ github.run_id }}-${{ github.run_attempt }}
          path: /tmp

      - name: Build test image
        uses: docker/build-push-action@v5
        with:
          context: ./${{ matrix.server }}
          platforms: linux/amd64
          push: false
          tags: ${{ matrix.server }}:test
          cache-from: type=gha

      - name: Test container startup
        run: |
          # Set dummy environment variables for testing
          ENV_VARS=""
          case "${{ matrix.server }}" in
            "sqlserver-mcp")
              ENV_VARS="-e SQLSERVER_SERVER=test-server.database.windows.net -e SQLSERVER_USERNAME=test-user -e SQLSERVER_PASSWORD=TestPass123! -e SQLSERVER_DATABASE=testdb"
              ;;
            "snowflake-mcp")
              ENV_VARS="-e SNOWFLAKE_ACCOUNT=test-account.us-east-1 -e SNOWFLAKE_USER=test-user -e SNOWFLAKE_PASSWORD=TestPass123! -e SNOWFLAKE_DATABASE=testdb -e SNOWFLAKE_WAREHOUSE=test_wh"
              ;;
            "databricks-mcp")
              ENV_VARS="-e DATABRICKS_SERVER_HOSTNAME=test.cloud.databricks.com -e DATABRICKS_HTTP_PATH=/sql/1.0/warehouses/test123 -e DATABRICKS_ACCESS_TOKEN=dapi123test456token"
              ;;
          esac
          
          echo "Testing ${{ matrix.server }} container startup..."
          CONTAINER_ID=$(docker run -d $ENV_VARS ${{ matrix.server }}:test)
          sleep 20
          
          LOGS=$(docker logs $CONTAINER_ID 2>&1)
          echo "Container logs:"
          echo "$LOGS"
          
          # Check if container is still running (basic health check)
          if docker ps | grep -q $CONTAINER_ID; then
            echo "âœ… Container started successfully"
            HEALTH_STATUS="healthy"
          else
            echo "âš ï¸ Container exited, checking logs for expected behavior"
            # For MCP servers, they might exit if they can't connect to test databases
            # This is expected behavior with dummy credentials
            if echo "$LOGS" | grep -E "(MCP server|listening|started|ready)" > /dev/null; then
              echo "âœ… Container validation passed - MCP server initialized"
              HEALTH_STATUS="healthy"
            elif echo "$LOGS" | grep -E "(connection.*failed|authentication.*failed|invalid.*credentials)" > /dev/null; then
              echo "âœ… Container validation passed - expected connection failure with test credentials"
              HEALTH_STATUS="healthy"
            else
              echo "âŒ Container failed validation - unexpected error"
              HEALTH_STATUS="failed"
            fi
          fi
          
          docker stop $CONTAINER_ID 2>/dev/null || true
          docker rm $CONTAINER_ID 2>/dev/null || true
          
          if [ "$HEALTH_STATUS" = "failed" ]; then
            exit 1
          fi

      - name: Security test
        run: |
          USER_INFO=$(docker run --rm ${{ matrix.server }}:test id 2>/dev/null || echo "uid=0")
          if echo "$USER_INFO" | grep -q "uid=1000"; then
            echo "âœ… Non-root user confirmed"
          else
            echo "âš ï¸ Security check: $USER_INFO"
          fi

  # Step 5: Publish images (per server, independent)
  publish-images:
    runs-on: ubuntu-latest
    needs: [detect-changes, build-images, test-containers]
    if: |
      always() && 
      needs.detect-changes.outputs.any-server == 'true' && 
      needs.build-images.result == 'success' &&
      (needs.test-containers.result == 'success' || needs.test-containers.result == 'skipped') &&
      ((github.event_name == 'push' && github.ref == 'refs/heads/main') ||
       (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) ||
       (github.event_name == 'workflow_dispatch' && github.event.inputs.publish == 'true'))
    strategy:
      matrix:
        server: ${{ fromJson(needs.detect-changes.outputs.servers-matrix) }}
      fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY_GHCR }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY_GHCR }}/${{ github.repository_owner }}/${{ matrix.server }}
          tags: |
            type=ref,event=branch
            type=semver,pattern={{version}}
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ github.event.inputs.version }},enable=${{ github.event_name == 'workflow_dispatch' }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./${{ matrix.server }}
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        continue-on-error: true
        with:
          path: ./${{ matrix.server }}
          format: spdx-json
          output-file: ${{ matrix.server }}-sbom.spdx.json

      - name: Upload SBOM
        uses: actions/upload-artifact@v4
        if: hashFiles('${{ matrix.server }}-sbom.spdx.json') != ''
        with:
          name: ${{ matrix.server }}-sbom-${{ github.run_id }}-${{ github.run_attempt }}
          path: ${{ matrix.server }}-sbom.spdx.json

  # Step 6: Create release (only for tags)
  create-release:
    runs-on: ubuntu-latest
    needs: [publish-images]
    if: startsWith(github.ref, 'refs/tags/v') && needs.publish-images.result == 'success'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all SBOMs
        uses: actions/download-artifact@v4
        with:
          path: ./sboms
          pattern: "*-sbom-${{ github.run_id }}-${{ github.run_attempt }}"

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: ./sboms/**/*.spdx.json
          body: |
            ## MCP Servers Release ${{ github.ref_name }}
            
            Container images available at:
            - `ghcr.io/${{ github.repository_owner }}/snowflake-mcp:${{ github.ref_name }}`
            - `ghcr.io/${{ github.repository_owner }}/databricks-mcp:${{ github.ref_name }}`
            - `ghcr.io/${{ github.repository_owner }}/sqlserver-mcp:${{ github.ref_name }}`

  # Step 7: Notification summary
  notify-results:
    runs-on: ubuntu-latest
    needs: [detect-changes, security-scan, build-images, test-containers, publish-images]
    if: always() && needs.detect-changes.outputs.any-server == 'true'
    steps:
      - name: Summary
        run: |
          echo "## Workflow Results" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ” Changes detected: ${{ needs.detect-changes.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ›¡ï¸ Security scan: ${{ needs.security-scan.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ”¨ Build images: ${{ needs.build-images.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ§ª Test containers: ${{ needs.test-containers.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸš€ Publish images: ${{ needs.publish-images.result }}" >> $GITHUB_STEP_SUMMARY
